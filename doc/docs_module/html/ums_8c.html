<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UMS module: ums.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UMS module
   </div>
   <div id="projectbrief">Windows UMS mechanism implementation for Linux distribution</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ums_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">ums.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file contains the implementation of all main functions of the module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ums_8h_source.html">ums.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f0ba61c7c4c5bcc133f227ce66671fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a6f0ba61c7c4c5bcc133f227ce66671fc">init_ums_process</a> (void)</td></tr>
<tr class="memdesc:a6f0ba61c7c4c5bcc133f227ce66671fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize/enable UMS in the process.  <a href="ums_8c.html#a6f0ba61c7c4c5bcc133f227ce66671fc">More...</a><br /></td></tr>
<tr class="separator:a6f0ba61c7c4c5bcc133f227ce66671fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021582c885c8a14b8ebd8d3846f975ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a021582c885c8a14b8ebd8d3846f975ba">exit_ums_process</a> (void)</td></tr>
<tr class="memdesc:a021582c885c8a14b8ebd8d3846f975ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete current process that enabled UMS.  <a href="ums_8c.html#a021582c885c8a14b8ebd8d3846f975ba">More...</a><br /></td></tr>
<tr class="separator:a021582c885c8a14b8ebd8d3846f975ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2655f2f806f114bf859a362324433f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a8c2655f2f806f114bf859a362324433f">exit_ums</a> (void)</td></tr>
<tr class="memdesc:a8c2655f2f806f114bf859a362324433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean/free the list of processes <a class="el" href="structprocess__list.html">process_list</a>.  <a href="ums_8c.html#a8c2655f2f806f114bf859a362324433f">More...</a><br /></td></tr>
<tr class="separator:a8c2655f2f806f114bf859a362324433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ce1900a0840e6b37a61c11f973cbb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a75ce1900a0840e6b37a61c11f973cbb9">create_completion_list</a> (void)</td></tr>
<tr class="memdesc:a75ce1900a0840e6b37a61c11f973cbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create completion list.  <a href="ums_8c.html#a75ce1900a0840e6b37a61c11f973cbb9">More...</a><br /></td></tr>
<tr class="separator:a75ce1900a0840e6b37a61c11f973cbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8cc7df36f79b361fa1c72961948571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#abc8cc7df36f79b361fa1c72961948571">create_worker_thread</a> (<a class="el" href="device__shared_8h.html#a7db527934bf7ffb83701317f9a073dd0">worker_thread_params_t</a> *params)</td></tr>
<tr class="memdesc:abc8cc7df36f79b361fa1c72961948571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create worker thread.  <a href="ums_8c.html#abc8cc7df36f79b361fa1c72961948571">More...</a><br /></td></tr>
<tr class="separator:abc8cc7df36f79b361fa1c72961948571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a276dd169c9225d57c5d8f55d53aba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a91a276dd169c9225d57c5d8f55d53aba">add_to_completion_list</a> (<a class="el" href="device__shared_8h.html#ab042f0a28f23e82580c274912cfe7d1b">add_wt_params_t</a> *params)</td></tr>
<tr class="memdesc:a91a276dd169c9225d57c5d8f55d53aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add worker thread to completion list.  <a href="ums_8c.html#a91a276dd169c9225d57c5d8f55d53aba">More...</a><br /></td></tr>
<tr class="separator:a91a276dd169c9225d57c5d8f55d53aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e3e330114076371db8a28d840d4f19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a52e3e330114076371db8a28d840d4f19">create_ums_thread</a> (<a class="el" href="device__shared_8h.html#a6ac8c9c6aa900b00f3b35300be5d16fe">ums_thread_params_t</a> *params)</td></tr>
<tr class="memdesc:a52e3e330114076371db8a28d840d4f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create ums thread(scheduler)  <a href="ums_8c.html#a52e3e330114076371db8a28d840d4f19">More...</a><br /></td></tr>
<tr class="separator:a52e3e330114076371db8a28d840d4f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e10182dc213395263cd6828d416bbd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a3e10182dc213395263cd6828d416bbd2">convert_to_ums_thread</a> (unsigned int ums_thread_id)</td></tr>
<tr class="memdesc:a3e10182dc213395263cd6828d416bbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert thread into ums thread(scheduler)  <a href="ums_8c.html#a3e10182dc213395263cd6828d416bbd2">More...</a><br /></td></tr>
<tr class="separator:a3e10182dc213395263cd6828d416bbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e220d694fcbee583e42701da8cd4896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a2e220d694fcbee583e42701da8cd4896">convert_from_ums_thread</a> (void)</td></tr>
<tr class="memdesc:a2e220d694fcbee583e42701da8cd4896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert back from ums thread(scheduler)  <a href="ums_8c.html#a2e220d694fcbee583e42701da8cd4896">More...</a><br /></td></tr>
<tr class="separator:a2e220d694fcbee583e42701da8cd4896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c1d2cb545625bcc03c9d1fdaeafbf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#aa4c1d2cb545625bcc03c9d1fdaeafbf1">dequeue_completion_list_items</a> (int *read_wt_list)</td></tr>
<tr class="memdesc:aa4c1d2cb545625bcc03c9d1fdaeafbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue completion list items.  <a href="ums_8c.html#aa4c1d2cb545625bcc03c9d1fdaeafbf1">More...</a><br /></td></tr>
<tr class="separator:aa4c1d2cb545625bcc03c9d1fdaeafbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88cdd76665d17307ce464e5182f3ccd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#af88cdd76665d17307ce464e5182f3ccd">switch_to_worker_thread</a> (unsigned int worker_thread_id)</td></tr>
<tr class="memdesc:af88cdd76665d17307ce464e5182f3ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch to worker thread.  <a href="ums_8c.html#af88cdd76665d17307ce464e5182f3ccd">More...</a><br /></td></tr>
<tr class="separator:af88cdd76665d17307ce464e5182f3ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0a7c9a0decf8a521b2e380f0fbb464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a2f0a7c9a0decf8a521b2e380f0fbb464">switch_back_to_ums_thread</a> (<a class="el" href="device__shared_8h.html#af6a037295cc215d38e0865102e652366">yield_reason_t</a> <a class="el" href="device__shared_8h.html#a173c832278e844627c9b4ac112127dd1">yield_reason</a>)</td></tr>
<tr class="memdesc:a2f0a7c9a0decf8a521b2e380f0fbb464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert back from worker thread.  <a href="ums_8c.html#a2f0a7c9a0decf8a521b2e380f0fbb464">More...</a><br /></td></tr>
<tr class="separator:a2f0a7c9a0decf8a521b2e380f0fbb464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675f8fb78aabe5442f47cb86e0a95664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a675f8fb78aabe5442f47cb86e0a95664">get_process_with_pid</a> (pid_t req_pid)</td></tr>
<tr class="memdesc:a675f8fb78aabe5442f47cb86e0a95664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get process structure from <a class="el" href="structprocess__list.html">process_list</a> with specific PID.  <a href="ums_8c.html#a675f8fb78aabe5442f47cb86e0a95664">More...</a><br /></td></tr>
<tr class="separator:a675f8fb78aabe5442f47cb86e0a95664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a162c63f1b0ad09dea0ee0dd29f4357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#a3aa2faf3090172d4cd003dbf1704efbb">completion_list_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a3a162c63f1b0ad09dea0ee0dd29f4357">get_cl_with_id</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>, unsigned int completion_list_id)</td></tr>
<tr class="memdesc:a3a162c63f1b0ad09dea0ee0dd29f4357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get completion list from <a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a> with specific id.  <a href="ums_8c.html#a3a162c63f1b0ad09dea0ee0dd29f4357">More...</a><br /></td></tr>
<tr class="separator:a3a162c63f1b0ad09dea0ee0dd29f4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3cee42b6891e083223c643fa1229f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#a122c865caa826d3b11882e53707fbf7e">worker_thread_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#aef3cee42b6891e083223c643fa1229f5">get_wt_with_id</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>, unsigned int worker_thread_id)</td></tr>
<tr class="memdesc:aef3cee42b6891e083223c643fa1229f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get worker thread from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a> with specific id.  <a href="ums_8c.html#aef3cee42b6891e083223c643fa1229f5">More...</a><br /></td></tr>
<tr class="separator:aef3cee42b6891e083223c643fa1229f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669f410186fca6be1184cfec91538482"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a669f410186fca6be1184cfec91538482">get_ready_wt_list</a> (<a class="el" href="ums_8h.html#a3aa2faf3090172d4cd003dbf1704efbb">completion_list_t</a> *<a class="el" href="structcompletion__list.html">completion_list</a>, unsigned int *ready_wt_list)</td></tr>
<tr class="memdesc:a669f410186fca6be1184cfec91538482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the array of integers with ready worker thread ids from completion list.  <a href="ums_8c.html#a669f410186fca6be1184cfec91538482">More...</a><br /></td></tr>
<tr class="separator:a669f410186fca6be1184cfec91538482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6053cda9b5ef3d9e380357b0db351f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#a122c865caa826d3b11882e53707fbf7e">worker_thread_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a6053cda9b5ef3d9e380357b0db351f8d">get_wt_run_by_umst_id</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>, unsigned int ums_thread_id)</td></tr>
<tr class="memdesc:a6053cda9b5ef3d9e380357b0db351f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get worker thread from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a> run by specific ums thread(scheduler)  <a href="ums_8c.html#a6053cda9b5ef3d9e380357b0db351f8d">More...</a><br /></td></tr>
<tr class="separator:a6053cda9b5ef3d9e380357b0db351f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71cdba8cfa9ab83b97c5a3a1bb3463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#ab7704f774ab72f95b456c1fcadb0c83f">ums_thread_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a4b71cdba8cfa9ab83b97c5a3a1bb3463">get_umst_with_id</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>, unsigned int ums_thread_id)</td></tr>
<tr class="memdesc:a4b71cdba8cfa9ab83b97c5a3a1bb3463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ums thread(scheduler) from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a> with specific id.  <a href="ums_8c.html#a4b71cdba8cfa9ab83b97c5a3a1bb3463">More...</a><br /></td></tr>
<tr class="separator:a4b71cdba8cfa9ab83b97c5a3a1bb3463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac030b78b6219960507cd37eb7e4dbeee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#ab7704f774ab72f95b456c1fcadb0c83f">ums_thread_context_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#ac030b78b6219960507cd37eb7e4dbeee">get_umst_run_by_pid</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>, pid_t req_pid)</td></tr>
<tr class="memdesc:ac030b78b6219960507cd37eb7e4dbeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ums thread(scheduler) from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a> run by specific thread.  <a href="ums_8c.html#ac030b78b6219960507cd37eb7e4dbeee">More...</a><br /></td></tr>
<tr class="separator:ac030b78b6219960507cd37eb7e4dbeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38247438dcbb475d4744d0463c5f5390"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a38247438dcbb475d4744d0463c5f5390">free_process_ums_thread_list</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>)</td></tr>
<tr class="memdesc:a38247438dcbb475d4744d0463c5f5390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean the list of ums threads(schedulers)  <a href="ums_8c.html#a38247438dcbb475d4744d0463c5f5390">More...</a><br /></td></tr>
<tr class="separator:a38247438dcbb475d4744d0463c5f5390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04223f98521c33aef04bd75585c49b88"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a04223f98521c33aef04bd75585c49b88">free_process_cl_list</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>)</td></tr>
<tr class="memdesc:a04223f98521c33aef04bd75585c49b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean the list of completion lists.  <a href="ums_8c.html#a04223f98521c33aef04bd75585c49b88">More...</a><br /></td></tr>
<tr class="separator:a04223f98521c33aef04bd75585c49b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a4721236a17583867c5cf2445e673c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a73a4721236a17583867c5cf2445e673c">free_process_worker_thread_list</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>)</td></tr>
<tr class="memdesc:a73a4721236a17583867c5cf2445e673c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean the list of worker threads.  <a href="ums_8c.html#a73a4721236a17583867c5cf2445e673c">More...</a><br /></td></tr>
<tr class="separator:a73a4721236a17583867c5cf2445e673c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302901f16efb6791d3b0d0514bfda7bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a302901f16efb6791d3b0d0514bfda7bf">free_process</a> (<a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *<a class="el" href="structprocess.html">process</a>)</td></tr>
<tr class="memdesc:a302901f16efb6791d3b0d0514bfda7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete/free process structure.  <a href="ums_8c.html#a302901f16efb6791d3b0d0514bfda7bf">More...</a><br /></td></tr>
<tr class="separator:a302901f16efb6791d3b0d0514bfda7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948cb61485daa4bbd00b17ced951c2fe"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a948cb61485daa4bbd00b17ced951c2fe">get_wt_running_time</a> (<a class="el" href="ums_8h.html#a122c865caa826d3b11882e53707fbf7e">worker_thread_context_t</a> *<a class="el" href="structworker__thread__context.html">worker_thread_context</a>)</td></tr>
<tr class="memdesc:a948cb61485daa4bbd00b17ced951c2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total runnning time of the worker thread.  <a href="ums_8c.html#a948cb61485daa4bbd00b17ced951c2fe">More...</a><br /></td></tr>
<tr class="separator:a948cb61485daa4bbd00b17ced951c2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225973539481835bbb121821f11ebbe3"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#a225973539481835bbb121821f11ebbe3">get_umst_switching_time</a> (<a class="el" href="ums_8h.html#ab7704f774ab72f95b456c1fcadb0c83f">ums_thread_context_t</a> *<a class="el" href="structums__thread__context.html">ums_thread_context</a>)</td></tr>
<tr class="memdesc:a225973539481835bbb121821f11ebbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the total switching time of the ums thread.  <a href="ums_8c.html#a225973539481835bbb121821f11ebbe3">More...</a><br /></td></tr>
<tr class="separator:a225973539481835bbb121821f11ebbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad96941d1139df32d935e2a7b467b87e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ums_8h.html#aeab9a7fcce181267a3e8390f4e5469c5">process_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ums_8c.html#ad96941d1139df32d935e2a7b467b87e3">process_list</a></td></tr>
<tr class="separator:ad96941d1139df32d935e2a7b467b87e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This file contains the implementation of all main functions of the module. </p>
<p >Copyright (C) 2021 Sultan Umarbaev <a href="#" onclick="location.href='mai'+'lto:'+'nam'+'e.'+'sul'+'27'+'@gm'+'ai'+'l.c'+'om'; return false;">name.<span style="display: none;">.nosp@m.</span>sul2<span style="display: none;">.nosp@m.</span>7@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a></p>
<p >This file is part of UMS implementation (Kernel Module).</p>
<p >UMS implementation (Kernel Module) is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p >UMS implementation (Kernel Module) is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p >You should have received a copy of the GNU General Public License along with UMS implementation (Kernel Module). If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Sultan Umarbaev <a href="#" onclick="location.href='mai'+'lto:'+'nam'+'e.'+'sul'+'27'+'@gm'+'ai'+'l.c'+'om'; return false;">name.<span style="display: none;">.nosp@m.</span>sul2<span style="display: none;">.nosp@m.</span>7@gma<span style="display: none;">.nosp@m.</span>il.c<span style="display: none;">.nosp@m.</span>om</a> </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a91a276dd169c9225d57c5d8f55d53aba" name="a91a276dd169c9225d57c5d8f55d53aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a276dd169c9225d57c5d8f55d53aba">&#9670;&nbsp;</a></span>add_to_completion_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int add_to_completion_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="device__shared_8h.html#ab042f0a28f23e82580c274912cfe7d1b">add_wt_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add worker thread to completion list. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary addition steps: Check if exists and get completion list with requested params::completion_list_id from <a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a>. Check if exists and get worker thread with requested params::worker_thread_id from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a>. Set <a class="el" href="structworker__thread__context.html#aeb201e41d85e5e5737d97f04bb020cb1">worker_thread_context::cl_id</a> to <a class="el" href="structcompletion__list.html#a053c1483124f251f5ce17414f0b36e80">completion_list::id</a> and add the worker thread to <a class="el" href="structcompletion__list.html#a35419b9ab0e3ef392a786fdc5e70a4ea">completion_list::wt_list</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>pointer to data structure shared to user space to pass parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a2e220d694fcbee583e42701da8cd4896" name="a2e220d694fcbee583e42701da8cd4896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e220d694fcbee583e42701da8cd4896">&#9670;&nbsp;</a></span>convert_from_ums_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int convert_from_ums_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert back from ums thread(scheduler) </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary convertion steps: Check if exists and get ums thread(scheduler) run by <code>current-&gt;pid</code> thread from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a>. Assign to structure necessary values:</p><ul>
<li><a class="el" href="structums__thread__context.html#a12fb7174037d944027a0dd3eed12d226">ums_thread_context::run_by</a> is set to -1</li>
<li><a class="el" href="structums__thread__context.html#ad39f49e374ec95ecf13c448283b4535a">ums_thread_context::state</a> is set to <a class="el" href="ums_8h.html#a20c07d57fac8a74722c0d3471d0472bdafd6a0e4343048b10646dd2976cc5ad18">ums_state_t::IDLE</a> Then, perform context switch operation:</li>
<li>switch current <code>pt_regs</code> and <code>fpu</code> structures to <a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a> and <a class="el" href="structums__thread__context.html#a01b56016d18235e154a353c29b2b8c68">ums_thread_context::fpu_regs</a></li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a3e10182dc213395263cd6828d416bbd2" name="a3e10182dc213395263cd6828d416bbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e10182dc213395263cd6828d416bbd2">&#9670;&nbsp;</a></span>convert_to_ums_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int convert_to_ums_thread </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ums_thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert thread into ums thread(scheduler) </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary convertion steps: Check if exists and get ums thread(scheduler) with requested ums_thread_id from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a>. Check if this ums thread(scheduler) is IDLE and not currently run by other thread. Save the context of the current thread:</p><ul>
<li><a class="el" href="structums__thread__context.html#a12fb7174037d944027a0dd3eed12d226">ums_thread_context::run_by</a> is set to <code>current-&gt;pid</code> </li>
<li><a class="el" href="structums__thread__context.html#ad39f49e374ec95ecf13c448283b4535a">ums_thread_context::state</a> is set to <a class="el" href="ums_8h.html#a20c07d57fac8a74722c0d3471d0472bda1061be6c3fb88d32829cba6f6b2be304">ums_state_t::RUNNING</a></li>
<li><a class="el" href="structums__thread__context.html#a22ab508a18133af3af2f6cf804d04ed6">ums_thread_context::switch_count</a> is increased by 1</li>
<li><a class="el" href="structums__thread__context.html#a5ecfdc22f1c91698ffd474e1a975f9b6">ums_thread_context::last_switch_time</a> is set to current time by ktime_get_real_ts64()</li>
<li><a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a> is set to the values of <code>task_pt_regs(current)</code> function</li>
<li><a class="el" href="structums__thread__context.html#a01b56016d18235e154a353c29b2b8c68">ums_thread_context::fpu_regs</a> is set to the values of <code>copy_fxregs_to_kernel()</code> function</li>
<li><a class="el" href="structums__thread__context.html#a85e0111a0c22f806eecd448f5ff8a642">ums_thread_context::ret_regs</a> is set to <a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a></li>
<li>ums_thread_context::regs::ip is set to <a class="el" href="structums__thread__context.html#a32aa3478a25c6fc832193a983c734823">ums_thread_context::entry_point</a> Then, perform context switch operation:</li>
<li>switch current <code>pt_regs</code> structure to <a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ums_thread_id</td><td>the id of the ums thread(scheduler) to be converted to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a75ce1900a0840e6b37a61c11f973cbb9" name="a75ce1900a0840e6b37a61c11f973cbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ce1900a0840e6b37a61c11f973cbb9">&#9670;&nbsp;</a></span>create_completion_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_completion_list </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create completion list. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary creation steps: Create a new completion list and return a corresponding id. Add the completion list to <a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a> and initialize <a class="el" href="structcompletion__list.html#a35419b9ab0e3ef392a786fdc5e70a4ea">completion_list::wt_list</a> for storing worker threads. Set <a class="el" href="structcompletion__list.html#a053c1483124f251f5ce17414f0b36e80">completion_list::id</a> to the current number of completion lists in <a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> completion list id </dd></dl>

</div>
</div>
<a id="a52e3e330114076371db8a28d840d4f19" name="a52e3e330114076371db8a28d840d4f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e3e330114076371db8a28d840d4f19">&#9670;&nbsp;</a></span>create_ums_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_ums_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="device__shared_8h.html#a6ac8c9c6aa900b00f3b35300be5d16fe">ums_thread_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create ums thread(scheduler) </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary creation steps: Create a new ums thread(scheduler) and add the ums thread(scheduler) to <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a>. Assign to structure all initial values and the ones passed by params parameter, hence:</p><ul>
<li><a class="el" href="structums__thread__context.html#a9b594f8c5ec95bdcc2bb90d6f5588721">ums_thread_context::id</a> is to the current number of ums threads in <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a></li>
<li><a class="el" href="structums__thread__context.html#a32aa3478a25c6fc832193a983c734823">ums_thread_context::entry_point</a> is set to the starting function passed by params::function</li>
<li><a class="el" href="structums__thread__context.html#aada95dacd52bb950a3fe8f1629d8d17a">ums_thread_context::cl_id</a> is set to params.completion_list_id</li>
<li><a class="el" href="structums__thread__context.html#aa66c738f2ee9ffa03198348143cc49c3">ums_thread_context::wt_id</a> is set to -1, no worker thread is currently run by ums thread(scheduler)</li>
<li><a class="el" href="structums__thread__context.html#abf06939bac9db7caede4234c208acc01">ums_thread_context::created_by</a> is set to <a class="el" href="structprocess.html#ab7b330a89c9b52c5f0c7dedd4f90dfb8">process::pid</a></li>
<li><a class="el" href="structums__thread__context.html#a12fb7174037d944027a0dd3eed12d226">ums_thread_context::run_by</a> is set to -1, no thread is currently running the ums thread(scheduler)</li>
<li><a class="el" href="structums__thread__context.html#ad39f49e374ec95ecf13c448283b4535a">ums_thread_context::state</a> is set to <a class="el" href="ums_8h.html#a20c07d57fac8a74722c0d3471d0472bdafd6a0e4343048b10646dd2976cc5ad18">ums_state_t::IDLE</a></li>
<li><a class="el" href="structums__thread__context.html#a22ab508a18133af3af2f6cf804d04ed6">ums_thread_context::switch_count</a> is set to 0 Additionaly, we create /proc/ums/&lt;PID&gt;/schedulers/&lt;ID&gt;, /proc/ums/&lt;PID&gt;/schedulers/&lt;ID&gt;/workers and /proc/ums/&lt;PID&gt;/schedulers/&lt;ID&gt;/info entries for ums thread(scheduler). As well as /proc/ums/&lt;PID&gt;/schedulers/&lt;ID&gt;/workers and /proc/ums/&lt;PID&gt;/schedulers/&lt;ID&gt;/workers/&lt;ID&gt; entries for each worker thread in the competion list associated with ums thread(scheduler).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>pointer to data structure shared to user space to pass parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> ums thread(scheduler) id </dd></dl>

</div>
</div>
<a id="abc8cc7df36f79b361fa1c72961948571" name="abc8cc7df36f79b361fa1c72961948571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8cc7df36f79b361fa1c72961948571">&#9670;&nbsp;</a></span>create_worker_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_worker_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="device__shared_8h.html#a7db527934bf7ffb83701317f9a073dd0">worker_thread_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create worker thread. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary creation steps: Create a new worker thread and return a corresponding id. Add the worker thread to <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a>. Assign to structure all initial values and the ones passed by params parameter, hence:</p><ul>
<li><a class="el" href="structworker__thread__context.html#afa9716132e7502ee44ffbfd96827226e">worker_thread_context::id</a> is to the current number of worker threads in <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a></li>
<li><a class="el" href="structworker__thread__context.html#a4dc5458fb6ced5ae28ee72bd70a1725f">worker_thread_context::entry_point</a> is set to the starting function passed by params::function</li>
<li><a class="el" href="structworker__thread__context.html#aad083bf9e4acb5588d86c0428f694b0e">worker_thread_context::created_by</a> is set to <a class="el" href="structprocess.html#ab7b330a89c9b52c5f0c7dedd4f90dfb8">process::pid</a></li>
<li><a class="el" href="structworker__thread__context.html#a0069c68289848a127b7758755f3ad4bc">worker_thread_context::run_by</a> is set to -1 because no scheduler is running the worker thread</li>
<li><a class="el" href="structworker__thread__context.html#a5874572082354fd3c22aab2bf32e23e6">worker_thread_context::state</a> is set to <a class="el" href="ums_8h.html#a74d6a8e9b05f036ec5b86d00abaffea6a6564f2f3e15be06b670547bbcaaf0798">worker_state_t::READY</a></li>
<li><a class="el" href="structworker__thread__context.html#ab065b954e4426a48bf0c4d2ec2884e9e">worker_thread_context::running_time</a> is set to 0</li>
<li><a class="el" href="structworker__thread__context.html#ac64a4db7d891f3ce348778b946556eab">worker_thread_context::switch_count</a> is set to 0</li>
<li><a class="el" href="structworker__thread__context.html#aefef0092884ac37e5a541b9a617a2a8f">worker_thread_context::regs</a> is set to the values of <code>task_pt_regs(current)</code> function</li>
<li>worker_thread_context::regs::ip is set to params::function, the starting function of the worker thread</li>
<li>worker_thread_context::regs::di is set to params::function_args, the arguments to the function</li>
<li>worker_thread_context::regs::sp is set to params::stack_address</li>
<li>worker_thread_context::regs::bp is set to params::stack_address</li>
<li><a class="el" href="structworker__thread__context.html#a6c2a3d2b66cf5537ac22f3866533b136">worker_thread_context::fpu_regs</a> is set to the values of <code>copy_fxregs_to_kernel()</code> function</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>pointer to data structure shared to user space to pass parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> worker thread id </dd></dl>

</div>
</div>
<a id="aa4c1d2cb545625bcc03c9d1fdaeafbf1" name="aa4c1d2cb545625bcc03c9d1fdaeafbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c1d2cb545625bcc03c9d1fdaeafbf1">&#9670;&nbsp;</a></span>dequeue_completion_list_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dequeue_completion_list_items </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>read_wt_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue completion list items. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary dequeue steps: Check if exists and get ums thread(scheduler) run by <code>current-&gt;pid</code> thread from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a>. Check if exists and get completion list associated with ums thread(scheduler) by <a class="el" href="structums__thread__context.html#aada95dacd52bb950a3fe8f1629d8d17a">ums_thread_context::cl_id</a>. Allocated temporary array of integers and fill it with rnnable worker thread ids with the help of auxiliary function <a class="el" href="ums_8c.html#a669f410186fca6be1184cfec91538482">get_ready_wt_list()</a>. Copy data from temporary array into array allocated by user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ready_wt_list</td><td>the pointer to an allocated by user array of integers which will be filled with ready to run worker thread ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a8c2655f2f806f114bf859a362324433f" name="a8c2655f2f806f114bf859a362324433f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2655f2f806f114bf859a362324433f">&#9670;&nbsp;</a></span>exit_ums()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exit_ums </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean/free the list of processes <a class="el" href="structprocess__list.html">process_list</a>. </p>
<p >Delete and free each item in the list of processes <a class="el" href="structprocess__list.html">process_list</a>. </p>

</div>
</div>
<a id="a021582c885c8a14b8ebd8d3846f975ba" name="a021582c885c8a14b8ebd8d3846f975ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021582c885c8a14b8ebd8d3846f975ba">&#9670;&nbsp;</a></span>exit_ums_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exit_ums_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete current process that enabled UMS. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Clean up memory allocated for the data structures that are associated with the process by <a class="el" href="ums_8c.html#a302901f16efb6791d3b0d0514bfda7bf">free_process()</a> funciton.</p>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a302901f16efb6791d3b0d0514bfda7bf" name="a302901f16efb6791d3b0d0514bfda7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302901f16efb6791d3b0d0514bfda7bf">&#9670;&nbsp;</a></span>free_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete/free process structure. </p>
<p >Delete and free specific process. In particular, delete every element in:</p><ul>
<li><a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a></li>
<li><a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a></li>
<li><a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a> And after that delete the process from <a class="el" href="structprocess__list.html">process_list</a>, the list of all processes that enabled UMS.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the process to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a04223f98521c33aef04bd75585c49b88" name="a04223f98521c33aef04bd75585c49b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04223f98521c33aef04bd75585c49b88">&#9670;&nbsp;</a></span>free_process_cl_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_process_cl_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean the list of completion lists. </p>
<p >Delete and free each item in the list of completion lists</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a38247438dcbb475d4744d0463c5f5390" name="a38247438dcbb475d4744d0463c5f5390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38247438dcbb475d4744d0463c5f5390">&#9670;&nbsp;</a></span>free_process_ums_thread_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_process_ums_thread_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean the list of ums threads(schedulers) </p>
<p >Delete and free each item in the list of ums threads(schedulers)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a73a4721236a17583867c5cf2445e673c" name="a73a4721236a17583867c5cf2445e673c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a4721236a17583867c5cf2445e673c">&#9670;&nbsp;</a></span>free_process_worker_thread_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_process_worker_thread_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean the list of worker threads. </p>
<p >Delete and free each item in the list of worker threads</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a3a162c63f1b0ad09dea0ee0dd29f4357" name="a3a162c63f1b0ad09dea0ee0dd29f4357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a162c63f1b0ad09dea0ee0dd29f4357">&#9670;&nbsp;</a></span>get_cl_with_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#a3aa2faf3090172d4cd003dbf1704efbb">completion_list_t</a> * get_cl_with_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>completion_list_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get completion list from <a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a> with specific id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
    <tr><td class="paramname">completion_list_id</td><td>the id of the completion list requested to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>completion_list_t</code> the pointer to completion list </dd></dl>

</div>
</div>
<a id="a675f8fb78aabe5442f47cb86e0a95664" name="a675f8fb78aabe5442f47cb86e0a95664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675f8fb78aabe5442f47cb86e0a95664">&#9670;&nbsp;</a></span>get_process_with_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> * get_process_with_pid </td>
          <td>(</td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>req_pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get process structure from <a class="el" href="structprocess__list.html">process_list</a> with specific PID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req_pid</td><td>the PID of the current process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>process_t</code> the pointer to process structure </dd></dl>

</div>
</div>
<a id="a669f410186fca6be1184cfec91538482" name="a669f410186fca6be1184cfec91538482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669f410186fca6be1184cfec91538482">&#9670;&nbsp;</a></span>get_ready_wt_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_ready_wt_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a3aa2faf3090172d4cd003dbf1704efbb">completion_list_t</a> *&#160;</td>
          <td class="paramname"><em>completion_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ready_wt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the array of integers with ready worker thread ids from completion list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structcompletion__list.html" title="The completion list of worker threads.">completion_list</a></td><td>the pointer to the completion list from which to get worker thread ids </td></tr>
    <tr><td class="paramname">ready_wt_list</td><td>the pointer to the array of integers that will be filled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="ac030b78b6219960507cd37eb7e4dbeee" name="ac030b78b6219960507cd37eb7e4dbeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac030b78b6219960507cd37eb7e4dbeee">&#9670;&nbsp;</a></span>get_umst_run_by_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#ab7704f774ab72f95b456c1fcadb0c83f">ums_thread_context_t</a> * get_umst_run_by_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>req_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ums thread(scheduler) from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a> run by specific thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
    <tr><td class="paramname">req_pid</td><td>the PID of the thread that runs ums thread(scheduler) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>ums_thread_context_t</code> the pointer to ums thread(scheduler) </dd></dl>

</div>
</div>
<a id="a225973539481835bbb121821f11ebbe3" name="a225973539481835bbb121821f11ebbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225973539481835bbb121821f11ebbe3">&#9670;&nbsp;</a></span>get_umst_switching_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_umst_switching_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#ab7704f774ab72f95b456c1fcadb0c83f">ums_thread_context_t</a> *&#160;</td>
          <td class="paramname"><em>ums_thread_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total switching time of the ums thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structums__thread__context.html" title="The ums thread(scheduler)">ums_thread_context</a></td><td>the pointer to the ums thread which swithcing time to be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>unsigned</code> <code>long</code> calculated total switching time </dd></dl>

</div>
</div>
<a id="a4b71cdba8cfa9ab83b97c5a3a1bb3463" name="a4b71cdba8cfa9ab83b97c5a3a1bb3463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b71cdba8cfa9ab83b97c5a3a1bb3463">&#9670;&nbsp;</a></span>get_umst_with_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#ab7704f774ab72f95b456c1fcadb0c83f">ums_thread_context_t</a> * get_umst_with_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ums_thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ums thread(scheduler) from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a> with specific id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
    <tr><td class="paramname">ums_thread_id</td><td>the id of the ums thread(scheduler) requested to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>ums_thread_context_t</code> the pointer to ums thread(scheduler) </dd></dl>

</div>
</div>
<a id="a6053cda9b5ef3d9e380357b0db351f8d" name="a6053cda9b5ef3d9e380357b0db351f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6053cda9b5ef3d9e380357b0db351f8d">&#9670;&nbsp;</a></span>get_wt_run_by_umst_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#a122c865caa826d3b11882e53707fbf7e">worker_thread_context_t</a> * get_wt_run_by_umst_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ums_thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get worker thread from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a> run by specific ums thread(scheduler) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
    <tr><td class="paramname">ums_thread_id</td><td>the id of the ums thread(scheduler) that runs worker thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>worker_thread_context_t</code> the pointer to worker thread </dd></dl>

</div>
</div>
<a id="a948cb61485daa4bbd00b17ced951c2fe" name="a948cb61485daa4bbd00b17ced951c2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948cb61485daa4bbd00b17ced951c2fe">&#9670;&nbsp;</a></span>get_wt_running_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_wt_running_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a122c865caa826d3b11882e53707fbf7e">worker_thread_context_t</a> *&#160;</td>
          <td class="paramname"><em>worker_thread_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the total runnning time of the worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structworker__thread__context.html" title="The worker thread.">worker_thread_context</a></td><td>the pointer to the worker thread which running time to be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>unsigned</code> <code>long</code> calculated running time </dd></dl>

</div>
</div>
<a id="aef3cee42b6891e083223c643fa1229f5" name="aef3cee42b6891e083223c643fa1229f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3cee42b6891e083223c643fa1229f5">&#9670;&nbsp;</a></span>get_wt_with_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#a122c865caa826d3b11882e53707fbf7e">worker_thread_context_t</a> * get_wt_with_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> *&#160;</td>
          <td class="paramname"><em>process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>worker_thread_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get worker thread from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a> with specific id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">process</td><td>the pointer to the process structure of the current process </td></tr>
    <tr><td class="paramname">worker_thread_id</td><td>the id of the worker thread requested to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>worker_thread_context_t</code> the pointer to worker thread </dd></dl>

</div>
</div>
<a id="a6f0ba61c7c4c5bcc133f227ce66671fc" name="a6f0ba61c7c4c5bcc133f227ce66671fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0ba61c7c4c5bcc133f227ce66671fc">&#9670;&nbsp;</a></span>init_ums_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_ums_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize/enable UMS in the process. </p>
<p >First, we check if the process has already enabled UMS. In order to start utilizing UMS mechanism, we need to enable UMS for the process. By this we create process element in the <a class="el" href="structprocess__list.html">process_list</a> which contains all processes that enbled UMS mechanism. If not, we create <a class="el" href="ums_8h.html#a0887f99826284e3828917609857e5e5c">process_t</a> and initialize:</p><ul>
<li><a class="el" href="structprocess.html#ab0972857847dcec4ae7095b0b5503ec1">process::cl_list</a> - A list of completion list in the process environment</li>
<li><a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a> - A list of worker thread in the process environment</li>
<li><a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a> - A list of ums thread(schedulers) in the process environment Additionaly, we create /proc/ums/&lt;PID&gt; and /proc/ums/&lt;PID&gt;/schedulers entries</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="a2f0a7c9a0decf8a521b2e380f0fbb464" name="a2f0a7c9a0decf8a521b2e380f0fbb464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0a7c9a0decf8a521b2e380f0fbb464">&#9670;&nbsp;</a></span>switch_back_to_ums_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int switch_back_to_ums_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="device__shared_8h.html#af6a037295cc215d38e0865102e652366">yield_reason_t</a>&#160;</td>
          <td class="paramname"><em>yield_reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert back from worker thread. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary convertion steps: Check if exists and get ums thread(scheduler) run by <code>current-&gt;pid</code> thread from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a>. Check if exists and get worker thread run by <a class="el" href="structums__thread__context.html#a9b594f8c5ec95bdcc2bb90d6f5588721">ums_thread_context::id</a> from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a>. Check if the yield reason is not <a class="el" href="ums_8h.html#a74d6a8e9b05f036ec5b86d00abaffea6aa6e504d57ec9777faa0185fbd3b93b97">yield_reason_t::BUSY</a> or <a class="el" href="ums_8h.html#a74d6a8e9b05f036ec5b86d00abaffea6adbd1812bee789fbf3548cf79d3f2b400">yield_reason_t::FINISHED</a>. Then, perform context saving and context switch operations:</p><ul>
<li><a class="el" href="structworker__thread__context.html#a0069c68289848a127b7758755f3ad4bc">worker_thread_context::run_by</a> is set to -1</li>
<li><a class="el" href="structworker__thread__context.html#a5874572082354fd3c22aab2bf32e23e6">worker_thread_context::state</a> is set to <a class="el" href="ums_8h.html#a74d6a8e9b05f036ec5b86d00abaffea6aa6e504d57ec9777faa0185fbd3b93b97">worker_state_t::BUSY</a> or <a class="el" href="ums_8h.html#a74d6a8e9b05f036ec5b86d00abaffea6adbd1812bee789fbf3548cf79d3f2b400">worker_state_t::FINISHED</a></li>
<li><a class="el" href="structworker__thread__context.html#ab065b954e4426a48bf0c4d2ec2884e9e">worker_thread_context::running_time</a> is set by auxiiary function <a class="el" href="ums_8c.html#a948cb61485daa4bbd00b17ced951c2fe">get_wt_running_time()</a></li>
<li><a class="el" href="structworker__thread__context.html#aefef0092884ac37e5a541b9a617a2a8f">worker_thread_context::regs</a> is set to the values of <code>task_pt_regs(current)</code> function</li>
<li><a class="el" href="structworker__thread__context.html#a6c2a3d2b66cf5537ac22f3866533b136">worker_thread_context::fpu_regs</a> is set to the values of <code>copy_fxregs_to_kernel()</code> function</li>
<li><a class="el" href="structums__thread__context.html#aa66c738f2ee9ffa03198348143cc49c3">ums_thread_context::wt_id</a> is set to -1</li>
<li>switch current <code>pt_regs</code> and <code>fpu</code> structures to <a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a> and <a class="el" href="structums__thread__context.html#a01b56016d18235e154a353c29b2b8c68">ums_thread_context::fpu_regs</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yield_reason</td><td>reason which defines if worker thread should be paused or finished, <a class="el" href="device__shared_8h.html#af6a037295cc215d38e0865102e652366">yield_reason_t</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<a id="af88cdd76665d17307ce464e5182f3ccd" name="af88cdd76665d17307ce464e5182f3ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88cdd76665d17307ce464e5182f3ccd">&#9670;&nbsp;</a></span>switch_to_worker_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int switch_to_worker_thread </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>worker_thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to worker thread. </p>
<p >First, we check if process that invokes this function is the one that enabled UMS. Then we perform all necessary convertion steps: Check if exists and get ums thread(scheduler) run by <code>current-&gt;pid</code> thread from <a class="el" href="structprocess.html#a8345f9b6261c56acd1a89bfa0ae7b129">process::ums_thread_list</a>. Check if exists and get worker thread with requested params::worker_thread_id from <a class="el" href="structprocess.html#a8304715a0688e07a8d3a8bc64bce8672">process::worker_thread_list</a>. Check if this worker thread is not BUSY and/or FINISHED. Save the context of the ums thread(scheduler):</p><ul>
<li><a class="el" href="structums__thread__context.html#aa66c738f2ee9ffa03198348143cc49c3">ums_thread_context::wt_id</a> is set to <a class="el" href="structworker__thread__context.html#afa9716132e7502ee44ffbfd96827226e">worker_thread_context::id</a></li>
<li><a class="el" href="structums__thread__context.html#a22ab508a18133af3af2f6cf804d04ed6">ums_thread_context::switch_count</a> is increased by 1</li>
<li><a class="el" href="structums__thread__context.html#a5ecfdc22f1c91698ffd474e1a975f9b6">ums_thread_context::last_switch_time</a> is set to current time by <code>ktime_get_real_ts64()</code> </li>
<li><a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a> is set to the values of <code>task_pt_regs(current)</code> function</li>
<li><a class="el" href="structums__thread__context.html#a85e0111a0c22f806eecd448f5ff8a642">ums_thread_context::ret_regs</a> is set to <a class="el" href="structums__thread__context.html#ae5c1f8b548fceaaef862bee953afc101">ums_thread_context::regs</a></li>
<li><a class="el" href="structums__thread__context.html#a01b56016d18235e154a353c29b2b8c68">ums_thread_context::fpu_regs</a> is set to the values of <code>copy_fxregs_to_kernel()</code> function</li>
<li><a class="el" href="structums__thread__context.html#a22ab508a18133af3af2f6cf804d04ed6">ums_thread_context::switch_count</a> is increased by 1</li>
<li><a class="el" href="structums__thread__context.html#a172287161e05473566433859037e9e24">ums_thread_context::switching_time</a> is set by an auxiliary function <a class="el" href="ums_8c.html#a225973539481835bbb121821f11ebbe3">get_umst_switching_time()</a></li>
</ul>
<p >Then, perform context switch operation:</p><ul>
<li><a class="el" href="structworker__thread__context.html#a0069c68289848a127b7758755f3ad4bc">worker_thread_context::run_by</a> is set to <a class="el" href="structums__thread__context.html#a9b594f8c5ec95bdcc2bb90d6f5588721">ums_thread_context::id</a></li>
<li><a class="el" href="structworker__thread__context.html#a5874572082354fd3c22aab2bf32e23e6">worker_thread_context::state</a> is set to <a class="el" href="ums_8h.html#a74d6a8e9b05f036ec5b86d00abaffea6aa6e504d57ec9777faa0185fbd3b93b97">worker_state_t::BUSY</a></li>
<li><a class="el" href="structworker__thread__context.html#ac64a4db7d891f3ce348778b946556eab">worker_thread_context::switch_count</a> is increased by 1</li>
<li><a class="el" href="structworker__thread__context.html#aa4b843564cc7c069d44deaa56c7e66bd">worker_thread_context::last_switch_time</a> is set to current time by <code>ktime_get_real_ts64()</code> </li>
<li>switch current <code>pt_regs</code> and <code>fpu</code> structures to <a class="el" href="structworker__thread__context.html#aefef0092884ac37e5a541b9a617a2a8f">worker_thread_context::regs</a> and <a class="el" href="structworker__thread__context.html#a6c2a3d2b66cf5537ac22f3866533b136">worker_thread_context::fpu_regs</a></li>
</ul>
<p ><b>NOTE</b>: If worker thread is BUSY function returns 2, if it is FINISHED it returns 1. These cases are not considered as real ERROR but handled as a special cases in userspace. In case of BUSY thread, scheduler in userspace will try to switch to next READY worker thread. For the case of FINISHED worker thread, scheduler in userpace will update list of ready worker threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_thread_id</td><td>the id of the worker thread to be switched to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>int</code> exit code 0 for success, otherwise a corresponding error code </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad96941d1139df32d935e2a7b467b87e3" name="ad96941d1139df32d935e2a7b467b87e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96941d1139df32d935e2a7b467b87e3">&#9670;&nbsp;</a></span>process_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ums_8h.html#aeab9a7fcce181267a3e8390f4e5469c5">process_list_t</a> <a class="el" href="structprocess__list.html">process_list</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .list = LIST_HEAD_INIT(<a class="code hl_struct" href="structprocess__list.html">process_list</a>.list),</div>
<div class="line">    .process_count = 0</div>
<div class="line">}</div>
<div class="ttc" id="astructprocess__list_html"><div class="ttname"><a href="structprocess__list.html">process_list</a></div><div class="ttdoc">The list of processes that initialized/enabled UMS mechanism.</div><div class="ttdef"><b>Definition:</b> ums.h:67</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="ums_8c.html">ums.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
